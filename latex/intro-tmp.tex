\chapter{Introduction}
\pagenumbering{arabic}

\section{Common Interfaces}
\subsection{The Queue, Stack, and Deque Interfaces}
\subsection{The List Interface}
\subsection{The Set and Map Interfaces}

The \mbox{\texttt{Set}} and \mbox{\texttt{Map}} interfaces are easily implemented by the following
interface:

\mbox{\texttt{add({\color{var}x})}}

\mbox{\texttt{remove({\color{var}x})}}: Remove, from the data structure the element that is equal to
\mbox{\texttt{{\color{var}x}}}, if one exists.

\mbox{\texttt{find({\color{var}x})}}: Find the element \mbox{\texttt{{\color{var}x}}} in the data structure. If there is an
element \mbox{\texttt{{\color{var}e}}} in the data structure equal to \mbox{\texttt{{\color{var}x}}}, then 
return a reference \mbox{\texttt{{\color{var}e}}}, otherwise return \mbox{\texttt{{\color{var}null}}}.


\subsection{The SortedSet and SortedMap Interfaces}

The \mbox{\texttt{SortedSet}} and \mbox{\texttt{SortedMap}} interfaces are easily implemented by the following
interface:

\mbox{\texttt{add({\color{var}x})}}

\mbox{\texttt{remove({\color{var}x})}}: Remove, from the data structure the element that is equal to
\mbox{\texttt{{\color{var}x}}}, if one exists.

\mbox{\texttt{find({\color{var}x})}}: 
Return the minimum element \mbox{\texttt{{\color{var}y}}} in the data structure such that
$\mbox{\texttt{{\color{var}y}}}\ge \mbox{\texttt{{\color{var}x}}}$. If no such element exists, then return \mbox{\texttt{{\color{var}null}}}.



\subsection{The DynamicString Interface}
\section{The Model of Computation}
\seclabel{model}
\begin{itemize}
\item Word-RAM, $c\log n$ bit words, can store values in $0,\ldots,n^{c}-1$.
\item Constant-time arithmetic, boolean, and bitwise boolean operations.
\item Constant time array accessing.  
\item Allocating an array of size \mbox{\texttt{{\color{var}n}}} takes $O(\mbox{\texttt{{\color{var}n}}})$ time.
\item Space is measured in words; items of type \mbox{\texttt{{\color{keyword}T}}}, \mbox{\texttt{{\color{keyword}K}}}, and \mbox{\texttt{{\color{keyword}V}}} take 1 word of memory each.
\end{itemize}

\section{Asymptotic Notation}

The usual stuff plus multivariate stuff.

$O(f(n_1,\ldots,n_3))$ means the set of all functions $g(n_1,\ldots,n_k)$ such that
$g(n_1,\ldots,n_k) \le c\cdot f(n_1,\ldots,n_3)$
for all $n_1,\ldots,n_k$ such that $f(n_1,\ldots,n_3)\ge n_0$.


\section{Amortization and Randomization}

\section{Code Samples}

The code samples in this book are written in the Java programming
language.  However to make the book accessible even to reader not
familiar with all of Java's constructs and keywords, the code samples have
been simplified.  For example, a reader won't find any of the keywords
\mbox{\texttt{{\color{keyword}public}}}, \mbox{\texttt{{\color{keyword}protected}}}, \mbox{\texttt{{\color{keyword}private}}}, or \mbox{\texttt{{\color{keyword}static}}}.  A reader also won't
find the \mbox{\texttt{{\color{keyword}extends}}} or \mbox{\texttt{{\color{keyword}implements}}} keywords, so any notion of class
hierarchy is missing.  Which interface a particular class implements
or which class it extends, if relevant to the discussion, will be clear
from the accompanying text.

These conventions should make most of the code samples understandable by
anyone with a background in any of the languages from the ALGOL tradition,
including B, C, C++, C\# Java, JavaScript, and so on.  Readers who want
the full details of all implementations are encouraged to look at the
Java source code that accompanies this book.


